/*! Hugo Blox Builder Tailwind UI v0.10.0 | https://hugoblox.com/ */
/*! Copyright 2016-present George Cushen (https://georgecushen.com/) */
/*! License: https://github.com/HugoBlox/hugo-blox-builder/blob/main/LICENSE.md */

;
(() => {
  // ns-hugo-params:<stdin>
  var hugoEnvironment = "development";
  var i18n = { copied: "Copied", copy: "" };

  // <stdin>
  var NOTIFICATION_DURATION = 2e3;
  var DEBOUNCE_DELAY = 300;
  var isDebugMode = hugoEnvironment === "development";
  var debounce = (func, wait) => {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };
  async function copyCodeToClipboard(button, codeWrapper) {
    if (!button || !(button instanceof HTMLElement)) {
      throw new Error("Invalid button element");
    }
    if (!codeWrapper || !(codeWrapper instanceof HTMLElement)) {
      throw new Error("Invalid code wrapper element");
    }
    const tempWrapper = codeWrapper.cloneNode(true);
    const copyButton = tempWrapper.querySelector(".copy-button");
    if (copyButton) {
      copyButton.remove();
    }
    const codeToCopy = tempWrapper.textContent?.trim() ?? "";
    if (!codeToCopy) {
      throw new Error("No code content found to copy");
    }
    try {
      await navigator.clipboard.writeText(codeToCopy);
      copiedNotification(button);
      isDebugMode && console.debug("Code copied successfully");
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Unknown error";
      console.error("Failed to copy:", errorMessage);
      button.innerHTML = i18n["copyFailed"] || "Failed";
      setTimeout(() => {
        button.innerHTML = i18n["copy"];
      }, NOTIFICATION_DURATION);
      throw err;
    }
  }
  function copiedNotification(copyBtn) {
    copyBtn.innerHTML = i18n["copied"];
    copyBtn.disabled = true;
    copyBtn.classList.add("copied");
    setTimeout(() => {
      copyBtn.innerHTML = i18n["copy"];
      copyBtn.disabled = false;
      copyBtn.classList.remove("copied");
    }, NOTIFICATION_DURATION);
  }
  function createCopyButton() {
    const copyBtn = document.createElement("button");
    copyBtn.classList.add("copy-button");
    copyBtn.innerHTML = i18n["copy"];
    copyBtn.setAttribute("aria-label", i18n["copyLabel"] || "Copy code to clipboard");
    copyBtn.setAttribute("type", "button");
    return copyBtn;
  }
  function getCodeWrapper(codeblock) {
    const container = codeblock.parentNode?.parentNode;
    if (!container) {
      throw new Error("Invalid code block structure");
    }
    if (container.classList.contains("highlight")) {
      return container;
    }
    const tableWrapper = container.closest("table");
    if (tableWrapper) {
      return tableWrapper;
    }
    const preElement = codeblock.parentElement;
    if (preElement) {
      preElement.classList.add("highlight");
      return preElement;
    }
    throw new Error("Could not determine code wrapper");
  }
  function initializeCodeCopyButtons() {
    try {
      const codeBlocks = document.querySelectorAll("pre > code");
      isDebugMode && console.debug(`Found ${codeBlocks.length} code blocks`);
      codeBlocks.forEach((codeblock, index) => {
        try {
          const wrapper = getCodeWrapper(codeblock);
          const copyBtn = createCopyButton();
          const debouncedCopy = debounce(() => copyCodeToClipboard(copyBtn, wrapper), DEBOUNCE_DELAY);
          copyBtn.addEventListener("click", debouncedCopy);
          wrapper.appendChild(copyBtn);
        } catch (err) {
          console.error(`Failed to initialize copy button for code block ${index}:`, err);
        }
      });
    } catch (err) {
      console.error("Failed to initialize code copy buttons:", err);
    }
  }
  if (document.readyState === "loading") {
    window.addEventListener("DOMContentLoaded", initializeCodeCopyButtons);
  } else {
    initializeCodeCopyButtons();
  }
})();

;
// Hugo Blox Builder Light / Dark theme toggle
document.addEventListener("DOMContentLoaded", () => {
  addThemeToggleListener();
});

function addThemeToggleListener() {
  const defaultTheme = window.hbb.defaultTheme;
  const themeToggleButtons = document.querySelectorAll(".theme-toggle");

  // Change the icons of the buttons based on previous settings or system theme
  if (
    localStorage.getItem("wc-color-theme") === "dark" ||
    (!("wc-color-theme" in localStorage) &&
      ((window.matchMedia("(prefers-color-scheme: dark)").matches && defaultTheme === "system") || defaultTheme === "dark"))
  ) {
    themeToggleButtons.forEach((el) => {
      el.dataset.theme = "dark";
    });
  } else {
    themeToggleButtons.forEach((el) => {
      el.dataset.theme = "light";
    });
  }

  // Add click event handler to the light/dark buttons
  themeToggleButtons.forEach((el) => {
    el.addEventListener("click", () => {
      console.debug("Theme toggled");
      if (localStorage.getItem("wc-color-theme")) {
        if (localStorage.getItem("wc-color-theme") === "light") {
          window.hbb.setDarkTheme();
          localStorage.setItem("wc-color-theme", "dark");
        } else {
          window.hbb.setLightTheme();
          localStorage.setItem("wc-color-theme", "light");
        }
      } else {
        if (document.documentElement.classList.contains("dark")) {
          window.hbb.setLightTheme();
          localStorage.setItem("wc-color-theme", "light");
        } else {
          window.hbb.setDarkTheme();
          localStorage.setItem("wc-color-theme", "dark");
        }
      }
      el.dataset.theme = document.documentElement.classList.contains("dark") ? "dark" : "light";

      // Dispatch `hbThemeChange` event to support themeable user plugins.
      const themeChangeEvent = new CustomEvent("hbThemeChange", {
        detail: {
          isDarkTheme: () => document.documentElement.classList.contains("dark"),
        },
      });
      document.dispatchEvent(themeChangeEvent);
    });
  });

  // Listen for dark mode toggling in OS
  window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (event) => {
    if (defaultTheme === "system" && !("wc-color-theme" in localStorage)) {
      event.matches ? window.hbb.setDarkTheme() : window.hbb.setLightTheme();
      themeToggleButtons.forEach((el) => {
        const isDark = document.documentElement.classList.contains("dark");
        el.dataset.theme = isDark ? "dark" : "light";
      });
    }
  });
}

;
window.addEventListener("DOMContentLoaded", () => {
  // Toggle language chooser sub-menu
  const languageChoosers = document.querySelectorAll("[data-hb-language-chooser]");
  languageChoosers.forEach((languageChooser) => {
    languageChooser.addEventListener("click", (e) => {
      e.preventDefault();
      languageChooser.dataset.state = languageChooser.dataset.state === "open" ? "closed" : "open";
      const languageOptions = languageChooser.nextElementSibling;
      languageOptions.classList.toggle("hidden");
      const languageChooserRect = languageChooser.getBoundingClientRect();
      const translateY = languageChooserRect.bottom - window.innerHeight + 40;
      languageOptions.style.transform = `translate3d(${languageChooserRect.left}px, ${translateY}px, 0)`;
      languageOptions.style.minWidth = `${Math.max(languageChooserRect.width, 50)}px`;
    });
  });

  // Handle clicks outside chooser
  document.addEventListener("click", (e) => {
    if (e.target.closest("[data-hb-language-chooser]") === null) {
      languageChoosers.forEach((languageChooser) => {
        languageChooser.dataset.state = "closed";
        const languageOptions = languageChooser.nextElementSibling;
        languageOptions.classList.add("hidden");
      });
    }
  });
});

;
// Navigation

const applyScrollPadding = () => {
  const header = document.querySelector(".page-header");
  const position = header.getBoundingClientRect();
  document.documentElement.style.scrollPaddingTop = position.height.toString() + "px";
  const r = document.querySelector(":root");
  r.style.setProperty("--navbar-height", position.height.toString() + "px");
};

window.addEventListener("DOMContentLoaded", () => {
  const dropdownMenus = document.querySelectorAll(".nav-dropdown > .nav-link[role='button']");

  dropdownMenus.forEach((toggler) => {
    const toggle = (el) => {
      const parent = el.closest(".nav-dropdown");
      const willActivate = !parent.classList.contains("active");
      parent.classList.toggle("active", willActivate);
      el.setAttribute("aria-expanded", willActivate ? "true" : "false");
    };

    toggler?.addEventListener("click", (e) => {
      e.preventDefault();
      toggle(e.currentTarget);
    });

    // Keyboard support
    toggler?.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        toggle(e.currentTarget);
      }
      if (e.key === "Escape") {
        const parent = e.currentTarget.closest(".nav-dropdown");
        parent?.classList.remove("active");
        e.currentTarget.setAttribute("aria-expanded", "false");
      }
    });
  });

  applyScrollPadding();
});

;
document.addEventListener("DOMContentLoaded", () => {
  const buttons = document.querySelectorAll("[data-hb-sidebar-toggle]");
  buttons.forEach((button) => {
    button.addEventListener("click", (e) => {
      e.preventDefault();
      const parent = button.parentElement.parentElement;
      if (parent) {
        parent.classList.toggle("open");
      }
    });
  });
});

// Hamburger menu for mobile navigation
document.addEventListener("DOMContentLoaded", () => {
  const menu = document.querySelector("#nav-toggle");
  const overlay = document.querySelector(".hb-sidebar-mobile-menu");
  const sidebarContainer = document.querySelector(".hb-sidebar-container");

  if (!overlay) {
    return;
  }

  // Initialize the overlay
  const overlayClasses = ["fixed", "z-10", "inset-0", "bg-white", "dark:bg-black/80"];
  overlay.classList.add("bg-transparent");
  overlay.classList.remove("hidden", ...overlayClasses);

  function toggleMenu() {
    // Toggle the hamburger menu
    // See `hb-nav.js` - it handles the default behavior (irrespective of if sidebar is shown).

    // When menu is open, show the navigation sidebar
    sidebarContainer.classList.toggle("max-lg:[transform:translate3d(0,-100%,0)]");
    sidebarContainer.classList.toggle("max-lg:[transform:translate3d(0,0,0)]");

    // When menu is open, prevent body from scrolling
    document.body.classList.toggle("overflow-hidden");
    document.body.classList.toggle("lg:overflow-auto");
  }

  menu.addEventListener("click", (e) => {
    console.debug("Hamburger clicked.");
    e.preventDefault();
    toggleMenu();

    if (overlay.classList.contains("bg-transparent")) {
      // Show overlay
      overlay.classList.add(...overlayClasses);
      overlay.classList.remove("bg-transparent");
    } else {
      // Hide overlay
      overlay.classList.remove(...overlayClasses);
      overlay.classList.add("bg-transparent");
    }
  });

  overlay.addEventListener("click", (e) => {
    e.preventDefault();
    toggleMenu();

    // Hide overlay
    overlay.classList.remove(...overlayClasses);
    overlay.classList.add("bg-transparent");
  });
});

;
(() => {
  // ns-hugo-params:<stdin>
  var hugoEnvironment = "development";

  // <stdin>
  var isDebugMode = hugoEnvironment === "development";
  function showNotification(message, type = "success", duration = 3e3) {
    const container = getOrCreateContainer();
    const existingNotification = container.querySelector(".hb-notification");
    if (existingNotification?.textContent?.includes(message)) {
      existingNotification.remove();
    }
    const notification = createNotificationElement(message, type);
    container.appendChild(notification);
    const closeBtn = notification.querySelector(".hb-notification-close");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => {
        removeNotification(notification);
      });
    }
    if (duration > 0) {
      setTimeout(() => {
        removeNotification(notification);
      }, duration);
    }
    return notification;
  }
  function getOrCreateContainer() {
    let container = document.getElementById("hb-notification-container");
    if (!container) {
      if (isDebugMode) {
        console.warn("Notification container not found, creating fallback");
      }
      container = document.createElement("div");
      container.id = "hb-notification-container";
      container.className = "fixed top-20 right-4 z-[9999] pointer-events-none";
      container.setAttribute("aria-live", "polite");
      container.setAttribute("aria-atomic", "true");
      document.body.appendChild(container);
    }
    return container;
  }
  function createNotificationElement(message, type) {
    const notification = document.createElement("div");
    notification.setAttribute("role", "alert");
    const colors = {
      success: { bg: "#10b981", bgClass: "bg-green-500" },
      error: { bg: "#ef4444", bgClass: "bg-red-500" },
      info: { bg: "#3b82f6", bgClass: "bg-blue-500" },
      warning: { bg: "#f59e0b", bgClass: "bg-amber-500" }
    };
    const color = colors[type] || colors.info;
    notification.className = `hb-notification pointer-events-auto flex items-center gap-2 px-4 py-3 text-white rounded-lg shadow-lg ${color.bgClass} animate-slide-in`;
    notification.style.cssText = `
    background-color: ${color.bg};
    color: white;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    margin-bottom: 0.5rem;
    pointer-events: auto;
  `;
    const icons = {
      success: '<svg class="w-5 h-5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>',
      error: '<svg class="w-5 h-5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>',
      info: '<svg class="w-5 h-5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>',
      warning: '<svg class="w-5 h-5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>'
    };
    const icon = icons[type] || icons.info;
    notification.innerHTML = `
    ${icon}
    <span class="text-sm font-medium">${message}</span>
    <button class="hb-notification-close ml-2 text-white/80 hover:text-white transition-colors" aria-label="Close">
      <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
      </svg>
    </button>
  `;
    ensureAnimationStyles();
    return notification;
  }
  function removeNotification(notification) {
    if (!notification || !notification.parentNode) return;
    notification.classList.remove("animate-slide-in");
    notification.classList.add("animate-slide-out");
    setTimeout(() => {
      if (notification.parentNode) {
        notification.remove();
      }
    }, 300);
  }
  function ensureAnimationStyles() {
    if (!document.querySelector("#hb-notification-styles")) {
      const style = document.createElement("style");
      style.id = "hb-notification-styles";
      style.textContent = `
      @keyframes slide-in {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      @keyframes slide-out {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100%);
          opacity: 0;
        }
      }
      .animate-slide-in {
        animation: slide-in 0.3s ease-out;
      }
      .animate-slide-out {
        animation: slide-out 0.3s ease-out;
      }
    `;
      document.head.appendChild(style);
    }
  }
  var stdin_default = showNotification;
})();

;
(() => {
  // ns-hugo-params:<stdin>
  var hugoEnvironment = "development";

  // <stdin>
  var isDebugMode = hugoEnvironment === "development";
  async function copyToClipboard(text) {
    if (navigator.clipboard && window.isSecureContext) {
      try {
        await navigator.clipboard.writeText(text);
        if (isDebugMode) {
          console.log("Copied using Clipboard API");
        }
        return true;
      } catch (err) {
        if (isDebugMode) {
          console.warn("Clipboard API failed:", err);
        }
      }
    }
    return copyUsingExecCommand(text);
  }
  function copyToClipboardSync(text) {
    return new Promise((resolve) => {
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(() => {
          if (isDebugMode) {
            console.log("Copied using Clipboard API (sync)");
          }
          resolve(true);
        }).catch((err) => {
          if (isDebugMode) {
            console.warn("Clipboard API failed:", err);
          }
          resolve(copyUsingExecCommand(text));
        });
      } else {
        resolve(copyUsingExecCommand(text));
      }
    });
  }
  function copyUsingExecCommand(text) {
    const textarea = document.createElement("textarea");
    textarea.value = text;
    Object.assign(textarea.style, {
      position: "fixed",
      top: "0",
      left: "0",
      width: "2em",
      height: "2em",
      padding: "0",
      border: "none",
      outline: "none",
      boxShadow: "none",
      background: "transparent",
      fontSize: "16px"
      // Prevent zoom on iOS
    });
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    if (navigator.userAgent.match(/ipad|iphone/i)) {
      const range = document.createRange();
      range.selectNodeContents(textarea);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      textarea.setSelectionRange(0, 999999);
    }
    let success = false;
    try {
      success = document.execCommand("copy");
      if (isDebugMode) {
        console.log(`execCommand copy ${success ? "succeeded" : "failed"}`);
      }
    } catch (err) {
      if (isDebugMode) {
        console.error("execCommand failed:", err);
      }
    }
    document.body.removeChild(textarea);
    return success;
  }
  function isClipboardAPIAvailable() {
    return !!(navigator.clipboard && window.isSecureContext);
  }
  var ClipboardCache = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    /**
     * Add content to cache
     * @param {string} key - Cache key
     * @param {string} content - Content to cache
     */
    set(key, content) {
      this.cache.set(key, content);
      if (isDebugMode) {
        console.log(`Cached clipboard content for: ${key}`);
      }
    }
    /**
     * Get content from cache
     * @param {string} key - Cache key
     * @returns {string|null} - Cached content or null
     */
    get(key) {
      return this.cache.get(key) || null;
    }
    /**
     * Check if content is cached
     * @param {string} key - Cache key
     * @returns {boolean} - Whether content is cached
     */
    has(key) {
      return this.cache.has(key);
    }
    /**
     * Clear the cache
     */
    clear() {
      this.cache.clear();
    }
    /**
     * Get cache size
     * @returns {number} - Number of cached items
     */
    get size() {
      return this.cache.size;
    }
  };
  var stdin_default = copyToClipboard;
})();

;
(() => {
  // ns-hugo-params:<stdin>
  var hugoEnvironment = "development";
  var i18n = { copied: "Copied", copy: "" };

  // ns-hugo-params:C:\Users\PC\AppData\Local\hugo_cache\modules\filecache\modules\pkg\mod\github.com\!hugo!blox\hugo-blox-builder\modules\blox-tailwind@v0.10.0\assets\js\hb-clipboard.js
  var hugoEnvironment2 = "development";

  // ns-hugo-imp:C:\Users\PC\AppData\Local\hugo_cache\modules\filecache\modules\pkg\mod\github.com\!hugo!blox\hugo-blox-builder\modules\blox-tailwind@v0.10.0\assets\js\hb-clipboard.js
  var isDebugMode = hugoEnvironment2 === "development";
  function copyToClipboardSync(text) {
    return new Promise((resolve) => {
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(() => {
          if (isDebugMode) {
            console.log("Copied using Clipboard API (sync)");
          }
          resolve(true);
        }).catch((err) => {
          if (isDebugMode) {
            console.warn("Clipboard API failed:", err);
          }
          resolve(copyUsingExecCommand(text));
        });
      } else {
        resolve(copyUsingExecCommand(text));
      }
    });
  }
  function copyUsingExecCommand(text) {
    const textarea = document.createElement("textarea");
    textarea.value = text;
    Object.assign(textarea.style, {
      position: "fixed",
      top: "0",
      left: "0",
      width: "2em",
      height: "2em",
      padding: "0",
      border: "none",
      outline: "none",
      boxShadow: "none",
      background: "transparent",
      fontSize: "16px"
      // Prevent zoom on iOS
    });
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    if (navigator.userAgent.match(/ipad|iphone/i)) {
      const range = document.createRange();
      range.selectNodeContents(textarea);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      textarea.setSelectionRange(0, 999999);
    }
    let success = false;
    try {
      success = document.execCommand("copy");
      if (isDebugMode) {
        console.log(`execCommand copy ${success ? "succeeded" : "failed"}`);
      }
    } catch (err) {
      if (isDebugMode) {
        console.error("execCommand failed:", err);
      }
    }
    document.body.removeChild(textarea);
    return success;
  }
  var ClipboardCache = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    /**
     * Add content to cache
     * @param {string} key - Cache key
     * @param {string} content - Content to cache
     */
    set(key, content) {
      this.cache.set(key, content);
      if (isDebugMode) {
        console.log(`Cached clipboard content for: ${key}`);
      }
    }
    /**
     * Get content from cache
     * @param {string} key - Cache key
     * @returns {string|null} - Cached content or null
     */
    get(key) {
      return this.cache.get(key) || null;
    }
    /**
     * Check if content is cached
     * @param {string} key - Cache key
     * @returns {boolean} - Whether content is cached
     */
    has(key) {
      return this.cache.has(key);
    }
    /**
     * Clear the cache
     */
    clear() {
      this.cache.clear();
    }
    /**
     * Get cache size
     * @returns {number} - Number of cached items
     */
    get size() {
      return this.cache.size;
    }
  };

  // ns-hugo-params:C:\Users\PC\AppData\Local\hugo_cache\modules\filecache\modules\pkg\mod\github.com\!hugo!blox\hugo-blox-builder\modules\blox-tailwind@v0.10.0\assets\js\hb-notifier.js
  var hugoEnvironment3 = "development";

  // ns-hugo-imp:C:\Users\PC\AppData\Local\hugo_cache\modules\filecache\modules\pkg\mod\github.com\!hugo!blox\hugo-blox-builder\modules\blox-tailwind@v0.10.0\assets\js\hb-notifier.js
  var isDebugMode2 = hugoEnvironment3 === "development";
  function showNotification(message, type = "success", duration = 3e3) {
    const container = getOrCreateContainer();
    const existingNotification = container.querySelector(".hb-notification");
    if (existingNotification?.textContent?.includes(message)) {
      existingNotification.remove();
    }
    const notification = createNotificationElement(message, type);
    container.appendChild(notification);
    const closeBtn = notification.querySelector(".hb-notification-close");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => {
        removeNotification(notification);
      });
    }
    if (duration > 0) {
      setTimeout(() => {
        removeNotification(notification);
      }, duration);
    }
    return notification;
  }
  function getOrCreateContainer() {
    let container = document.getElementById("hb-notification-container");
    if (!container) {
      if (isDebugMode2) {
        console.warn("Notification container not found, creating fallback");
      }
      container = document.createElement("div");
      container.id = "hb-notification-container";
      container.className = "fixed top-20 right-4 z-[9999] pointer-events-none";
      container.setAttribute("aria-live", "polite");
      container.setAttribute("aria-atomic", "true");
      document.body.appendChild(container);
    }
    return container;
  }
  function createNotificationElement(message, type) {
    const notification = document.createElement("div");
    notification.setAttribute("role", "alert");
    const colors = {
      success: { bg: "#10b981", bgClass: "bg-green-500" },
      error: { bg: "#ef4444", bgClass: "bg-red-500" },
      info: { bg: "#3b82f6", bgClass: "bg-blue-500" },
      warning: { bg: "#f59e0b", bgClass: "bg-amber-500" }
    };
    const color = colors[type] || colors.info;
    notification.className = `hb-notification pointer-events-auto flex items-center gap-2 px-4 py-3 text-white rounded-lg shadow-lg ${color.bgClass} animate-slide-in`;
    notification.style.cssText = `
    background-color: ${color.bg};
    color: white;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    margin-bottom: 0.5rem;
    pointer-events: auto;
  `;
    const icons = {
      success: '<svg class="w-5 h-5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>',
      error: '<svg class="w-5 h-5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>',
      info: '<svg class="w-5 h-5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>',
      warning: '<svg class="w-5 h-5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>'
    };
    const icon = icons[type] || icons.info;
    notification.innerHTML = `
    ${icon}
    <span class="text-sm font-medium">${message}</span>
    <button class="hb-notification-close ml-2 text-white/80 hover:text-white transition-colors" aria-label="Close">
      <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
      </svg>
    </button>
  `;
    ensureAnimationStyles();
    return notification;
  }
  function removeNotification(notification) {
    if (!notification || !notification.parentNode) return;
    notification.classList.remove("animate-slide-in");
    notification.classList.add("animate-slide-out");
    setTimeout(() => {
      if (notification.parentNode) {
        notification.remove();
      }
    }, 300);
  }
  function ensureAnimationStyles() {
    if (!document.querySelector("#hb-notification-styles")) {
      const style = document.createElement("style");
      style.id = "hb-notification-styles";
      style.textContent = `
      @keyframes slide-in {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      @keyframes slide-out {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100%);
          opacity: 0;
        }
      }
      .animate-slide-in {
        animation: slide-in 0.3s ease-out;
      }
      .animate-slide-out {
        animation: slide-out 0.3s ease-out;
      }
    `;
      document.head.appendChild(style);
    }
  }

  // <stdin>
  var isDebugMode3 = hugoEnvironment === "development";
  var citationCache = new ClipboardCache();
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeCitation);
  } else {
    initializeCitation();
  }
  function initializeCitation() {
    document.addEventListener("click", handleCiteClick);
    document.addEventListener("mouseover", prefetchOnHover);
    document.addEventListener("focusin", prefetchOnHover);
    prefetchAllCitations();
  }
  function prefetchAllCitations() {
    const citeButtons = document.querySelectorAll(".js-cite-clipboard[data-filename]");
    citeButtons.forEach((button) => {
      const filename = button.getAttribute("data-filename");
      if (filename && !citationCache.has(filename)) {
        fetchAndCacheCitation(filename);
      }
    });
  }
  function prefetchOnHover(e) {
    const citeButton = e.target.closest(".js-cite-clipboard");
    if (!citeButton) return;
    const filename = citeButton.getAttribute("data-filename");
    if (filename && !citationCache.has(filename)) {
      fetchAndCacheCitation(filename);
    }
  }
  async function fetchAndCacheCitation(filename) {
    try {
      const response = await fetch(filename);
      if (!response.ok) {
        throw new Error(`Failed to fetch citation: ${response.statusText}`);
      }
      const citation = await response.text();
      citationCache.set(filename, citation);
      return citation;
    } catch (error) {
      if (isDebugMode3) {
        console.error(`Failed to fetch citation ${filename}:`, error);
      }
      return null;
    }
  }
  function handleCiteClick(e) {
    const citeButton = e.target.closest(".js-cite-clipboard");
    if (!citeButton) return;
    e.preventDefault();
    e.stopPropagation();
    const filename = citeButton.getAttribute("data-filename");
    if (!filename) {
      if (isDebugMode3) {
        console.error("No filename specified for citation");
      }
      showNotification("Citation file not found", "error");
      return;
    }
    const cachedCitation = citationCache.get(filename);
    if (cachedCitation) {
      copyToClipboardSync(cachedCitation).then((success) => {
        if (success) {
          showNotification(i18n?.copied || "Citation copied!", "success");
          updateButtonText(citeButton);
        } else {
          showNotification("Failed to copy citation", "error");
        }
      });
    } else {
      fetchAndCopyWithFallback(filename, citeButton);
    }
  }
  async function fetchAndCopyWithFallback(filename, button) {
    try {
      const citation = await fetchAndCacheCitation(filename);
      if (citation) {
        const success = await copyToClipboardSync(citation);
        if (success) {
          showNotification(i18n?.copied || "Citation copied!", "success");
          updateButtonText(button);
        } else {
          showNotification("Failed to copy citation", "error");
        }
      } else {
        showNotification("Failed to load citation", "error");
      }
    } catch (error) {
      if (isDebugMode3) {
        console.error("Failed to copy citation:", error);
      }
      if (error.name === "NotAllowedError") {
        showNotification("Please hover over the button first, then click", "info");
      } else {
        showNotification("Failed to copy citation", "error");
      }
    }
  }
  function updateButtonText(button) {
    const copiedText = i18n?.copied || "Copied!";
    const textElement = button.querySelector("span");
    if (!textElement) {
      if (isDebugMode3) {
        console.warn("Could not find text element in cite button");
      }
      return;
    }
    const originalText = textElement.textContent;
    textElement.textContent = copiedText;
    button.classList.add("opacity-70");
    setTimeout(() => {
      textElement.textContent = originalText;
      button.classList.remove("opacity-70");
    }, 2e3);
  }
})();
